Emulates Perl's Carp module
http://search.cpan.org/~dapm/perl-5.10.1/lib/Carp.pm as best as possible to
warn or die of errors in programs written in C.

The following macros are defined for use:

-   warn - prints message with the file and line
-   die - like a warn that exits the program
-   carp - warn of errors (from perspective of caller)
-   croak - die of errors (from perspective of caller)
-   cluck - warn of errors with stack backtrace
-   confess - die of errors with stack backtrace

There are also the macros ewarn, edie, ecarp, ecroak, ecluck, econfess which
work just like the previous macros but add an errno string to your message.

There are also the macros swarn, sdie, scarp, scroak, scluck, sconfess, eswarn,
esdie, escroak, escluck, and esconfess that return the string the original
macro would have outputted. The s* variants will not exit the program. The
returned string will need to be freed.

SYNOPSIS
========

    #include <carp.h>
    #line 3 "libb"
    void foo4() {
        warn("warn");
        carp("carp");
        cluck("cluck");
    }
    void foo3() {foo4();}
    #line 10 "liba"
    void foo2() {foo3();}
    void foo1() {foo2();}
    void bar2() {
        warn("warn");
        carp("carp");
        cluck("cluck");
        croak("croak");
    }
    void bar1() {bar2();}
    #line 20 "test1.c"
    int main() {
        foo1();
        bar1();
        return 0;
    }

Results in:

    warn at libb line 4
    carp at liba line 10
    cluck at libb line 6
        foo4() called at libb line 8
        foo3() called at liba line 10
        foo2() called at liba line 11
        foo1() called at test1.c line 21
    warn at liba line 13
    carp at test1.c line 22
    cluck at liba line 15
        bar2() called at liba line 18
        bar1() called at test1.c line 22
    croak at test1.c line 22


DESCRIPTION
===========

This library works by reading from a an attached gdb process. If unable to
get info from a stack trace, carp and cluck revert to a warn and croak and
confess revert to a die. However, even with debugging (gcc's -g option) 
disabled requesting a stacktrace may provide some useful information. It uses 
files instead of packages (as Perl does) to determine the trust divide.

On Windows, the stack trace is recieved by walking the stack, and getting
return addresses, which are looked up in the pdbs if they are available.

Carp trusts all functions up to the first shared library change. This
means that when you call carp or croak it will print the first location it
finds in a different shared library. with static libraries (libyup.a or
yup.lib), it is impossible from a debugging standpoint to differentiate it from
a normal object linking.

Carp differs slightly from the Carp module in Perl: Since it may be common
for a program written in C to link with a static library that uses Carp, I
decided not to default to a full stack trace when a trust boundary isn't found.
Rather a carp will become like a warn.

PLANS
=====

Fix tests.
Windows too.
Settings too.
Change strip to strip_to which will leave a number of path elements.
Remove plan for trusted/suspected files. We dont need em.
Implement trusted/suspected libs.
color_output_builtin().
Document better.

